package com.example.hazmatapp.Model

import android.content.ContentValues
import android.util.Log
import androidx.lifecycle.MutableLiveData
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.ktx.auth
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.ValueEventListener
import com.google.firebase.database.ktx.database
import com.google.firebase.ktx.Firebase

class FirebaseRepository {

    private val database = Firebase.database.reference // Database reference
    private lateinit var auth: FirebaseAuth // Firebase authenticator reference
    private val usersPath = database.child("users") // Creates a parent node in the JSON file
    val readingsList: MutableLiveData<List<Reading>> = MutableLiveData() // Holds a list of readings

    fun addUser(user: User) {
        val path = user.id?.let { usersPath.child(it) } // Creates path to new user child using firebase authenticator id

        path?.setValue(user)?.addOnSuccessListener {
            Log.d("Firestore", "User added successfully with ID: $user.id")
        }?.addOnFailureListener { e ->
            Log.w("Firestore", "Error adding user", e)
        }
    }
    fun addReading(reading: Reading){ // Adds reading to the user's data
        auth = Firebase.auth // Initializes authenticator instance
        val currentUserID = auth.currentUser?.uid // ID of the current user

        // Create a path for the new reading in the form users -> currentUser -> readings -> newReading
        val path = currentUserID?.let { database.child("users").child(it).child("readings").push() }

        val newKey = path?.key // the ID generated by the path
        reading.id = newKey // Adds the ID to the reading to be able to retrieve it later on

        path?.setValue(reading)?.addOnSuccessListener {
            Log.d("Firestore", "Reading added successfully with ID: $currentUserID.id")
        }?.addOnFailureListener { e ->
            Log.w("Firestore", "Error adding reading", e)
        }

    }

    fun deleteReading(reading: Reading) { // Deletes reading from user's data
        auth = Firebase.auth // Initializes authenticator instance
        val readingID = reading.id
        Log.d("ReadingID", "$readingID")
        val currentUserID = auth.currentUser?.uid // ID of the current user
        val path = database.child("users").child(currentUserID.toString()).child("readings")
            .child(readingID.toString()).removeValue()
        path.addOnSuccessListener {
            Log.d("Firebase", "SUCCESS DELETING READING '$readingID'")
        }.addOnFailureListener { e ->
            Log.d("Firebase", "ERROR DELETING READING '$readingID'", e)
        }
    }

    fun getAllReadings() { // This method fetches all the readings stored in the firebase database
        auth = Firebase.auth // Initializes authenticator instance
        val currentUserID = auth.currentUser?.uid // ID of the current user

        currentUserID?.let { database.child("users").child(it).child("readings") }
            ?.addValueEventListener(object : ValueEventListener {
                override fun onDataChange(snapshot: DataSnapshot) { // snapshot represents the task node
                    if (snapshot.exists()) { // Checks if there is any data(records)  at the task node
                        val tempArray = arrayListOf<Reading>()
                        for (taskSnapshot in snapshot.children) { // For each record in the task node
                            val reading =
                                taskSnapshot.getValue(Reading::class.java) // Gets the task in the form of a Task object
                            if (reading != null) {
                                tempArray.add(reading) // Adds the Task object to the array
                            }
                        }
                        // Adds all the record stored in the array to the MutableLiveData array
                        this@FirebaseRepository.readingsList.value = tempArray
                    }
                }

                override fun onCancelled(error: DatabaseError) {
                    Log.w("Repository", "Error getting the data", error.toException())
                }
            })
    }

}